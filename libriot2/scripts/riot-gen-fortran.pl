#!/usr/bin/perl -w
#
# Adapted from darshan scripts for use with LDPLFS
#
#  (C) 2009 by Argonne National Laboratory.
#      See COPYRIGHT in top-level directory.
#

# takes a standard mpifortran script as an argument and tried to generate a
# ldplfs mpifortran script to mimic it's behavior

use Getopt::Long;
use English;

## Parse a settings file ##
open(CONFIG, "settings.txt");
while (<CONFIG>) { 
	chomp; # no newline 
	s/#.*//; # no comments 
	s/^\s+//; # no leading white 
	s/\s+$//; # no trailing white 
	next unless length; # anything left? 
	my ($var, $value) = split(/\s*=\s*/, $_, 2); 
	$UP{$var} = $value; 
}
close(CONFIG);

$FUNCTION_WRAPPERS="-Wl,-wrap,write,-wrap,open,-wrap,open64,-wrap,close,-wrap,read,-wrap,pread,-wrap,pwrite,-wrap,pread64,-wrap,pwrite64,-wrap,fnctl";

my $input_file = "";
my $output_file = "";
my $trim_exe_path=0;
my $xl_check = 0;

process_args();

# run original mpicc with -show argument to capture command line for
# compilation and linking
my $compile_cmd = `$input_file -show -c foo.c`;
if (!($compile_cmd))
{
    printf STDERR "Error: failed to invoke $input_file with -show\n";
    exit(1);
}

my $link_cmd = `$input_file -show foo.o -o foo`;
if (!($link_cmd))
{
    printf STDERR "Error: failed to invoke $input_file with -show\n";
    exit(1);
}

# we just want the first line of output from the mpi script's -v argument;
# the rest we assume will be generated by the underlying compiler
my $version_out = `$input_file -v 2>/dev/null |head -n 1`;
if (!($version_out))
{
    printf STDERR "Error: failed to invoke $input_file with -v\n";
    exit(1);
}

# check command lines for accuracy
if(!($compile_cmd =~ /-c foo.c/) || !($link_cmd =~ /foo.o -o foo/))
{
    printf STDERR "Error: faulty output from $input_file with -show.\n";
    exit(1);
}
chomp($compile_cmd);
chomp($link_cmd);
chomp($version_out);

#
# Incomprehensible re to eat the leading path of the compiler command
# and only give the basename.
#
# /cmd -> cmd
# cmd -> cmd
# /x/y/x/z/cmd -> cmd
#
if($trim_exe_path)
{
    $compile_cmd =~ s/\/*([^\/ ]+\/)*//;
    $link_cmd =~ s/\/*([^\/ ]+\/)*//;
}

open (OUTPUT, ">$output_file") || die("Error opening output file: $!");

# substitute arguments and ldplfs options into commands
$base_link_cmd = $link_cmd;
$base_link_cmd =~ s/foo.o -o foo/"\$\{allargs\[\@\]\}"/g;
$link_cmd =~ s/foo.o -o foo/"\$\{newallargs\[\@\]\}" -L$UP{RIOT_LIB_PATH} \$FMPICH -lriot $FUNCTION_WRAPPERS/g;
$link_cmd =~ s/$/ -L$UP{RIOT_LIB_PATH} -lriot/g;
$compile_cmd =~ s/-c foo.c/"\$\{allargs\[\@\]\}"/g;

# create link cmd with noshrargs variable
$link_cmd_no_shared = $base_link_cmd;
$link_cmd_no_shared =~ s/allargs/noshrargs/;

print OUTPUT<<'EOF';
#!/bin/bash
#
# Auto-generated mpifortran script from ldplfs-gen-fortran.pl
#
#
# Internal variables
# Show is set to echo to cause the compilation command to be echoed instead 
# of executed.
Show=
EOF

if ($xl_check == 1)
{
print OUTPUT<<'EOF';
#
# Check for IBM XL Linker Parameters
#
# If IPA linker is used, we must disable ldplfs
# because the IPA linker doesn't support -wrap.
#
function check_XL()
{
    arg=$1;
    ipa_enabled=0;

    if [ "$arg" = "-O5" ]; then
        ipa_enabled=1;
    fi
    if [ "$arg" = "-O4" ]; then
        ipa_enabled=1;
    fi
    if [ "$arg" = "-qipa" ]; then
        ipa_enabled=1;
    fi

    return $ipa_enabled;
}
EOF
}

print OUTPUT<<'EOF';
linking=yes
allargs=("$@")
argno=0
for arg in "$@" ; do
    # Set addarg to no if this arg should be ignored by the C compiler
    addarg=yes
    case "$arg" in 
 	# ----------------------------------------------------------------
	# Compiler options that affect whether we are linking or no
    -c|-S|-E|-M|-MM)
    # The compiler links by default
    linking=no
    ;;
    -v)
    # Pass this argument to the compiler as well.
EOF
print OUTPUT<<"EOF";
    echo "$version_out"
EOF
print OUTPUT<<'EOF';
    # if there is only 1 argument, it must be -v.
    if [ "$#" -eq "1" ] ; then
        linking=no
    fi
    ;;
    -show)
    addarg=no
    Show=echo
    ;;
    esac
    if [ $addarg = no ] ; then
	unset allargs[$argno]
    fi
    # Some versions of bash do not accept ((argno++))
    argno=`expr $argno + 1`
done
if [ "$linking" = yes ] ; then
    if [ -n "$C_LINKPATH_SHL" ] ; then
	# prepend the path for the shared libraries to the library list
	mpilibs="$C_LINKPATH_SHL$libdir $mpilibs"
    fi
EOF
print OUTPUT<<"EOF";
    # if allargs includes any libraries, then we need to get
    # -lldplfs in there first
    argno=0;
    once=0;
    compiler_check=0;
    newallargs=\("\$\{allargs\[\@\]\}"\);
    for arg in "\$\{newallargs\[\@\]\}"; do
        res=`expr match "\$arg" "-l"`;
        if [ \$res -gt 0 -a \$once -lt 1 ]; then
            newallargs[\$argno]=-llplfs
            argno=`expr \$argno + 1`
            newallargs[\$argno]=\$arg;
            once=1;
        else
            newallargs[\$argno]=\$arg;
        fi
EOF

#
# Add any functional tests for linker parameters
#
       if ($xl_check)
       {
print OUTPUT<<"EOF";
           check_XL "\$arg";
           if [ \$? -ne 0 ]; then
               compiler_check=1;
           fi
EOF
       }

print OUTPUT<<"EOF";

        argno=`expr \$argno + 1`
    done

    # create a temporary file
    tmpfile=`mktemp`
    # generate a map of the symbol names
    # don't use -shared for this step
    argno=0
    noshrargs=\("\$\{allargs\[\@\]\}");
    for arg in "\$\{noshrargs\[\@\]\}"; do
        if [ "\$arg" = "-shared" ]; then
            unset noshrarg[\$argno];
        fi
        argno=`expr \$argno + 1`
    done
    $link_cmd_no_shared -Wl,-Map,\$tmpfile \$LDFLAGS -o /dev/null >& /dev/null

    # normal or cnk libraries?
    grep -E mpich\\.cnk \$tmpfile >& /dev/null
    rc_cnk_check=\$?
    if [ \$rc_cnk_check -eq 0 ] ; then
        FMPICH=-lfmpich.cnk
    else
        FMPICH=-lfmpich
    fi

    rm \$tmpfile >& /dev/null


    if [ \$rc_pmpi -ne 0 ] && [ \$compiler_check -eq 0 ]; then
       \$Show $link_cmd
    else
       \$Show $base_link_cmd
    fi

    rc=\$?
else
    \$Show $compile_cmd
    rc=\$?
fi

exit \$rc
EOF

close(OUTPUT);

chmod(0755, $output_file); 

exit(0);

sub process_args
{
    use vars qw( $opt_help $opt_output $opt_trim $opt_xl );

    Getopt::Long::Configure("no_ignore_case", "bundling");
    GetOptions( "help",
        "output=s",
        "trim",
        "xl");

    if($opt_help)
    {
        print_help();
        exit(0);
    }

    if($opt_trim)
    {
        $trim_exe_path=1;
    }

    if($opt_xl)
    {
        $xl_check=1;
    }

    if($opt_output)
    {
        $output_file = $opt_output;
    }
    else
    {
        print_help();
        exit(1);
    }

    # there should only be one remaining argument: the input file 
    if($#ARGV != 0)
    {
        print "Error: invalid arguments.\n";
        print_help();
        exit(1);
    }
    $input_file = $ARGV[0];

    return;
}

sub print_help
{
    print<<"EOF";

Usage: $PROGRAM_NAME <stock mpifortran> --output <modified mpifortran>

    --help          Prints this help message
    --output        Specifies name of output script
    --trim          Trim the compilers path
    --xl            Disables ldplfs if certain linker parameters are used
                    (Intended for IBM XL Compilers)

Purpose:

    This script takes an existing mpif77 script as input and generates a
    modified version that includes ldplfs support.

Credit:

    This script is a modified version of the scripts provided by Darshan
    from the Argonne National Laboratory.

EOF
    return;
}

